<!DOCTYPE html>
<!--
--------------------------------------------------------------------------------------------------
IP Address (v4): 10.0.0.1 # example
Subnet Mask: /25 # example 
--------------------------------------------------------------------------------------------------
[[ Calculate ]] #
--------------------------------------------------------------------------------------------------
Item	         Value
IP Class	     Class A
IP Type          Private
--------------------------------------------------------------------------------------------------
IP Address   	 10.0.0.1
Subnet Mask	     255.255.255.128 (11111111.11111111.11111111.10000000)
Wildcard Mask	 0.0.0.127 (00000000.00000000.00000000.01111111)
CIDR Notation	 10.0.0.1/25
Network Address	 10.0.0.0 (00001010.00000000.00000000.00000000)
Broadcast	     10.0.0.127 (00001010.00000000.00000000.01111111)
Host Range	     10.0.0.1 - 10.0.0.126
Azure Host Range 10.0.0.4 - 10.0.0.126
Total Hosts  	 128
Usable Hosts	 126
Usable Azure IPs 123
Subnet (binary)	 11111111.11111111.11111111.10000000
IP (binary)	     00001010.00000000.00000000.00000001
Subnets
Subnet address	 Azure Subnet usable IPs	Azure usable Hosts   	Divide	Join
10.0.0.0/28	      10.0.0.4 - 10.0.0.14	              11            Divide  Join
10.0.0.16/28	 10.0.0.20 - 10.0.0.30                11	        Divide  Join
10.0.0.32/27     10.0.0.36 - 10.0.0.62                27	        Divide  Join
10.0.0.64/26     10.0.0.68 - 10.0.0.126               59	        Divide  Join
--------------------------------------------------------------------------------------------------
REPO: https://github.com/agustinborrajo/GNIgetnetworkinfo-TestIPportConnection-IPcalculator
--------------------------------------------------------------------------------------------------
FILENAME = IP-subnet-calculator-divide-join.html
--------------------------------------------------------------------------------------------------
HOSTING = http://agustin.50megs.com/IPcalc/
--------------------------------------------------------------------------------------------------
-->
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=.5, minimum-scale=0.1, user-scalable=yes" />
  <link rel="icon" href="http://agustin.50megs.com/agustinicon.png" />
  <title> IP_calculator</title>
  <style>
    html, body {
      height: 100%;
      background: #181c24;
      color: #fff;
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 800px;
      margin-left: 0;
      padding: 1em;
      box-sizing: border-box;
    }
    h2 {
      text-align: left;
      font-size: 1.4em;
      color: #2ab7ca;
    }
    label {
      display: block;
      margin: 1em 0 0.2em 0;
    }
    input[type="text"], select {
      width: 100%;
      font-size: 1.1em;
      padding: 0.5em;
      background: #222831;
      color: #fff;
      border: 1px solid #2ab7ca;
      border-radius: 0.3em;
      margin-bottom: 0.5em;
    }
    button, .action {
      display: inline-block;
      background: #2ab7ca;
      color: #181c24;
      border: none;
      border-radius: 0.3em;
      padding: 0.35em 0.6em;
      font-size: 0.95em;
      font-weight: bold;
      cursor: pointer;
      margin: 0 0.25em;
    }
    .action[disabled] {
      background: #444b52;
      color: #b8c6c8;
      cursor: not-allowed;
      opacity: 0.65;
    }
    button[onclick] {
      display: block;
      width: 100%;
      padding: 0.7em;
      margin-top: 1em;
    }
    .results {
      background: #23272f;
      border-radius: 0.5em;
      padding: 1em;
      margin-top: 1.5em;
      box-shadow: 0 0 6px #2ab7ca55;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1em 0 0 0;
      font-size: 0.98em;
    }
    th, td {
      padding: 0.35em 0.5em;
      text-align: left;
      border-bottom: 1px solid #444;
      word-break: break-all;
    }
    th {
      color: #2ab7ca;
      background: #181c24;
    }
    .binary {
      font-family: "Fira Mono", "Consolas", monospace;
      color: #96d3fa;
    }
    .small {
      color: #7edbba;
      font-size: 0.92em;
    }
    .subnet-actions { white-space: nowrap; }
    @media (max-width: 900px) {
      .container { max-width: 99vw; padding: 1vw; }
      table, th, td { font-size: 0.93em; }
    }
  </style>
</head>
<body>
  <div class="container">
     <h2>&#127760; IP + Subnet Calculator &#128242;</h2>
    <label>IP Address (v4):
      <input type="text" id="ip" placeholder="e.g. 10.0.0.1" />
    </label>
    <label>Subnet Mask:
      <input type="text" id="mask" placeholder="e.g. /24 or 255.255.255.0 or 11111111.11111111.11111111.00000000" />
    </label>
    <button onclick="calcIP()" id="calcBtn">Calculate</button>

    <div class="results" id="results" style="display:none;"></div>

    <!-- Subnets management area (populated after calculate) -->
    <div class="results" id="subnetsArea" style="display:none;">
      <h3 style="margin:0 0 0.5em 0; color:#2ab7ca;">Subnets</h3>
      <div id="subnetsTableWrapper"></div>
    </div>
  </div>

  <script>
    /* Utility conversions */
    function toInt(ip) {
      let p = ip.split('.').map(x => parseInt(x, 10));
      if (p.length !== 4 || p.some(n => isNaN(n) || n < 0 || n > 255)) return null;
      return ((p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]) >>> 0;
    }
    function toIP(int) {
      return [(int >>> 24) & 255, (int >>> 16) & 255, (int >>> 8) & 255, int & 255].join('.');
    }
    function toBin(ip) {
      return ip.split('.').map(o => parseInt(o,10).toString(2).padStart(8,'0')).join('.');
    }
    function prefix2mask(prefix) {
      let n = parseInt(prefix, 10);
      if (isNaN(n) || n < 0 || n > 32) return null;
      let mask = ((0xFFFFFFFF << (32 - n)) >>> 0);
      return toIP(mask);
    }
    function mask2prefix(mask) {
      mask = (mask||'').trim();
      if (mask.startsWith('/')) return parseInt(mask.slice(1),10);
      if (/^[01.]+$/.test(mask)) {
        const bits = mask.replace(/\./g,'');
        if (bits.length !== 32) return null;
        if (!/^1*0*$/.test(bits)) return null;
        return bits.indexOf('0') === -1 ? 32 : bits.indexOf('0');
      }
      let bitsInt = toInt(mask);
      if (bitsInt == null) return null;
      let s = bitsInt.toString(2).padStart(32,'0');
      if (!/^1*0*$/.test(s)) return null;
      return s.replace(/0/g,'').length;
    }

    function hosts(prefix) {
      let h = Math.max(0, 2 ** (32 - prefix));
      let usable = prefix == 31 ? 2 : (prefix == 32 ? 1 : Math.max(0, h - 2));
      let azureUsable = h >= 6 ? h - 5 : 0;
      return { total: h, usable: usable, azureUsable: azureUsable };
    }

    function wildcard(maskStr) {
      return maskStr.split('.').map(a => 255 - parseInt(a,10)).join('.');
    }

    function ipClass(ip) {
      let p = ip.split('.').map(x => parseInt(x,10));
      if (p[0] >=1 && p[0] <=126) return { c:'A', cls:'classA' };
      if (p[0] == 127) return { c:'A (Loopback)', cls:'classA' };
      if (p[0] >=128 && p[0] <=191) return { c:'B', cls:'classB' };
      if (p[0] >=192 && p[0] <=223) return { c:'C', cls:'classC' };
      if (p[0] >=224 && p[0] <=239) return { c:'D (Multicast)', cls:'classD' };
      if (p[0] >=240 && p[0] <=255) return { c:'E (Experimental)', cls:'classE' };
      return { c:'Unknown', cls:'' };
    }

    /* Subnet list state (always kept sorted by netInt ascending) */
    let subnets = []; // each entry: {netInt: number, prefix: int}

    function sortSubnets() {
      subnets.sort((a,b) => {
        if (a.netInt !== b.netInt) return (a.netInt >>> 0) - (b.netInt >>> 0);
        return a.prefix - b.prefix;
      });
    }

    /* Render functions for subnets area (no Subnet name) */
    function renderSubnets() {
      const wrap = document.getElementById('subnetsTableWrapper');
      if (!subnets.length) {
        wrap.innerHTML = "<div class='small'>No subnets</div>";
        document.getElementById('subnetsArea').style.display = 'none';
        return;
      }

      // Ensure sorted for adjacency logic
      sortSubnets();

      // Build table header (removed Subnet name)
      let html = "<table><tr><th>Subnet address</th><th>Azure Subnet usable IPs</th><th>Azure usable Hosts</th><th>Divide</th><th>Join</th></tr>";
      for (let i=0;i<subnets.length;i++) {
        const s = subnets[i];
        const mask = prefix2mask(s.prefix);
        const azureUsable = hosts(s.prefix).azureUsable;
        const nw = s.netInt >>> 0;
        const bc = (nw | (~(toInt(mask)>>>0))) >>> 0;

        let azureRange = 'n/a';
        if (azureUsable > 0) {
          const aMinInt = (nw + 4) >>> 0;
          const aMaxInt = (bc - 1) >>> 0;
          azureRange = toIP(aMinInt) + " - " + toIP(aMaxInt);
        }
        const azureUsableStr = azureUsable > 0 ? String(azureUsable) : '<span class="small">n/a</span>';
        const canDivide = s.prefix < 32;

        // Determine joinability:
        //  - sibling must exist (same prefix, same parent) AND
        //  - sibling must be immediate neighbor in the sorted array (no other subnet between them)
        let siblingIndex = -1;
        if (s.prefix > 0) {
          const halfSize = 2 ** (32 - s.prefix);
          const siblingNet = (s.netInt ^ halfSize) >>> 0;
          for (let j=0;j<subnets.length;j++) {
            if (j === i) continue;
            if (subnets[j].prefix === s.prefix && subnets[j].netInt === siblingNet) {
              siblingIndex = j;
              break;
            }
          }
        }
        // adjacency check: sibling must exist and be adjacent index in sorted subnets
        const isAdjacent = siblingIndex !== -1 && Math.abs(siblingIndex - i) === 1;
        const canJoin = siblingIndex !== -1 && isAdjacent;

        // tabindex ordering: address, azureRange, azureUsable, divide button, join button
        html += "<tr>";
        html += "<td>" + toIP(nw) + "/" + s.prefix + "</td>";
        html += "<td>" + azureRange + "</td>";
        html += "<td>" + azureUsableStr + "</td>";
        html += "<td class='subnet-actions'><button class='action' onclick='divideSubnet(" + i + ")' " + (canDivide ? "" : "disabled") + " tabindex='0'>Divide</button></td>";
        // Join button: disabled if not joinable; visually greyed by CSS for disabled attribute
        html += "<td class='subnet-actions'><button class='action' onclick='joinSubnet(" + i + ")' " + (canJoin ? "" : "disabled") + " tabindex='0'>Join</button></td>";
        html += "</tr>";
      }
      html += "</table>";
      wrap.innerHTML = html;
      document.getElementById('subnetsArea').style.display = 'block';
    }

    /* Divide a subnet into two subnets with prefix+1 */
    function divideSubnet(index) {
      // operate on sorted list: index refers to sorted subnets
      if (index < 0 || index >= subnets.length) return;
      const s = subnets[index];
      if (!s || s.prefix >= 32) return;
      const newPrefix = s.prefix + 1;
      const size = 2 ** (32 - newPrefix);
      const firstNet = s.netInt >>> 0;
      const secondNet = (firstNet + size) >>> 0;
      // Replace the original subnet with two new ones
      subnets.splice(index, 1, {netInt: firstNet, prefix: newPrefix}, {netInt: secondNet, prefix: newPrefix});
      sortSubnets();
      renderSubnets();
    }

    /* Join a subnet with sibling (if present and adjacent) */
    function joinSubnet(index) {
      if (index < 0 || index >= subnets.length) return;
      const s = subnets[index];
      if (!s || s.prefix === 0) return;
      const halfSize = 2 ** (32 - s.prefix);
      const siblingNet = (s.netInt ^ halfSize) >>> 0;
      let sibIdx = -1;
      for (let j=0;j<subnets.length;j++) {
        if (j === index) continue;
        if (subnets[j].prefix === s.prefix && subnets[j].netInt === siblingNet) {
          sibIdx = j;
          break;
        }
      }
      if (sibIdx === -1) return;
      sortSubnets();
      const iSorted = subnets.findIndex(x => x.netInt === s.netInt && x.prefix === s.prefix);
      const jSorted = subnets.findIndex(x => x.netInt === siblingNet && x.prefix === s.prefix);
      if (iSorted === -1 || jSorted === -1 || Math.abs(iSorted - jSorted) !== 1) return;
      const parentPrefix = s.prefix - 1;
      const parentMaskInt = ((0xFFFFFFFF << (32 - parentPrefix)) >>> 0) >>> 0;
      const parentNet = (s.netInt & parentMaskInt) >>> 0;
      const low = Math.min(iSorted, jSorted);
      subnets.splice(low, 2, {netInt: parentNet, prefix: parentPrefix});
      sortSubnets();
      renderSubnets();
    }

    /* calcIP (original behavior preserved) */
    function calcIP() {
      let ip = document.getElementById('ip').value.trim();
      let maskInput = document.getElementById('mask').value.trim();

      let ipi = toInt(ip);
      let prefix = mask2prefix(maskInput);

      if (ipi === null || prefix === null || prefix > 32) {
        document.getElementById('results').style.display = 'block';
        document.getElementById('results').innerHTML =
          "<span class='small'>Invalid input. Use format: 192.168.0.1 and 255.255.255.0 or /24 or 11111111.11111111.11111111.00000000.</span>";
        subnets = [];
        renderSubnets();
        return;
      }

      let maskStr = prefix2mask(prefix);
      let maskInt = toInt(maskStr);
      let nw = (ipi & maskInt) >>> 0;
      let bc = (nw | (~maskInt)) >>> 0;
      let hostmin = (prefix == 32) ? ipi : (prefix == 31) ? nw : nw + 1;
      let hostmax = (prefix >= 31) ? ipi : (bc - 1);
      let hostsObj = hosts(prefix);
      let ipClassObj = ipClass(ip);
      let ipClassStr = "<span class='" + ipClassObj.cls + "'>Class " + ipClassObj.c + "</span>";
      let ipType = isPrivate(ip)
        ? "<span class='private'>Private</span>"
        : "<span class='public'>Public</span>";

      let azureUsableStr = hostsObj.total >= 6 ? hostsObj.azureUsable : '<span class="small">n/a</span>';

      let azureHostMin = 'n/a';
      let azureHostMax = 'n/a';
      if (hostsObj.azureUsable > 0) {
        azureHostMin = toIP((nw + 4) >>> 0);
        azureHostMax = toIP((bc - 1) >>> 0);
      }

      document.getElementById('results').style.display = 'block';
      document.getElementById('results').innerHTML =
        "<table>" +
        "<tr><th>Item</th><th>Value</th></tr>" +
        "<tr><td>IP Class</td><td>" + ipClassStr + "</td></tr>" +
        "<tr><td>IP Type</td><td>" + ipType + "</td></tr>" +
        "<tr><td>IP Address</td><td>" + ip + "</td></tr>" +
        "<tr><td>Subnet Mask</td><td>" + maskStr + " <span class='small'>(" + toBin(maskStr) + ")</span></td></tr>" +
        "<tr><td>Wildcard Mask</td><td>" + wildcard(maskStr) + " <span class='small'>(" + toBin(wildcard(maskStr)) + ")</span></tr>" +
        "<tr><td>CIDR Notation</td><td>" + ip + "/" + prefix + "</td></tr>" +
        "<tr><td>Network Address</td><td>" + toIP(nw) + " <span class='small'>(" + toBin(toIP(nw)) + ")</span></td></tr>" +
        "<tr><td>Broadcast</td><td>" + toIP(bc) + " <span class='small'>(" + toBin(toIP(bc)) + ")</span></td></tr>" +
        "<tr><td>Host Range</td><td>" + toIP(hostmin) + " - " + toIP(hostmax) + "</td></tr>" +
        "<tr><td>Azure Host Range</td><td>" + azureHostMin + " - " + azureHostMax + "</td></tr>" +
        "<tr><td>Total Hosts</td><td>" + hostsObj.total + "</td></tr>" +
        "<tr><td>Usable Hosts</td><td>" + hostsObj.usable + "</td></tr>" +
        "<tr><td>Usable Azure IPs</td><td>" + azureUsableStr + "</td></tr>" +
        "<tr><td>Subnet (binary)</td><td class='binary'>" + toBin(maskStr) + "</td></tr>" +
        "<tr><td>IP (binary)</td><td class='binary'>" + toBin(ip) + "</td></tr>" +
        "</table>";

      // Initialize subnets list with this single network (sorted by design)
      subnets = [{ netInt: nw >>> 0, prefix: prefix }];
      sortSubnets();
      renderSubnets();
    }

    function isPrivate(ip) {
      let p = ip.split('.').map(x => parseInt(x, 10));
      if (p.length < 2 || isNaN(p[0]) || isNaN(p[1])) return false;
      if (p[0] == 10) return true;
      if (p[0] == 172 && p[1] >= 16 && p[1] <= 31) return true;
      if (p[0] == 192 && p[1] == 168) return true;
      return false;
    }

    /* --- New: support Enter key to trigger calculate when focused on IP or Mask --- */
    (function enableEnterKey() {
      const ipInput = document.getElementById('ip');
      const maskInput = document.getElementById('mask');
      function handleKey(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          calcIP();
        }
      }
      ipInput.addEventListener('keydown', handleKey);
      maskInput.addEventListener('keydown', handleKey);
      // also allow Enter when focus is anywhere in the form container: optional
      document.querySelector('.container').addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          const active = document.activeElement;
          // only trigger when focus is on an input or button (avoid unintended submits)
          if (active && (active.id === 'ip' || active.id === 'mask')) {
            e.preventDefault();
            calcIP();
          }
        }
      });
    })();
  </script>
</body>
</html>